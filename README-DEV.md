# README for Developers

## CI Infrastructure

### Overview

The overall goal for this CI is to compare checksums generated by the `ACCESS-OM2` model using a particular config branch/tag against a 'ground truth' checksum.

The Reproducibility CI is comprised of two main triggers: on Pull Request and Scheduled Checks. Both make use of reusable workflows and custom actions in the [ACCESS-NRI/reproducibility](https://github.com/ACCESS-NRI/reproducibility) repository.

### Triggered On Pull Request

This pipeline uses the `pr-1-ci.yml` workflow for the majority of the PR lifecycle.

It also uses `bump-version-file.yml`, `bump-tag.yml` and `prevent-merge.yml` to control supplementary actions like bumping the VERSION file correctly, updating the config tag on merge, and preventing merges when the VERSION file has not been updated in the PR.

The overall pipeline looks like this:

```txt
PR: pr-1-ci.yml -> prevent-merge.yml -> bump-version-file.yml, then
Merge: bump-tag.yml
```

#### The PR CI Lifecycle: `pr-1-ci.yml`

This file does the bulk of the handling of the PR.

##### `commit-check`

The first job, `commit-check`, is used to short-circuit execution of this workflow in the case where the latest commit was authored by `github-actions`, so there isn't a recursive cycle of checking and adding to the PR.

`github-actions` authors commits to the `CHECKSUM` and `VERSION` files in the PR.

##### `repro-ci`

This job uses a reusable workflow that runs a given model on Gadi using a particular config tag (in this case, it'll be the source PR branch), and uploads the checksum as an artifact named `<model>-<config-tag>`, for example, `access-om2-release-config-fix`.

Note that the `environment-name` refers to the [GitHub Actions Environment](https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment) that is defined in _this repository_, not the repository that houses the reusable workflow.

##### `check-repro`

This job compares the checksum in the given `<model>-<config-tag>` artifact against the checksum in the 'ground truth' config tag, which is often the most recent config tag in the PR target branch.

In the case where the checksums do not match, the CI pushes a commit to the PR with the updated checksum, and prevents merging until there is an appropriate `VERSION` bump. See the [section on the `prevent-merge.yml` workflow](#preventing-half-formed-prs-prevent-mergeyml).

##### `result`

In this final stage, we add a comment to the Pull Request advising the creator of the result of the Repro check, as well as informing them of any actions that they need to take before the PR can be merged - most likely a required bump to the `VERSION` file, as is explained below.

#### Updating `VERSION`: `bump-version-file.yml`

The `VERSION` file is used to source the new config tag when the PR is eventually merged.

This workflow is triggered on the creation of a comment on the pull request, where the comment matches `!bump [major|minor]`. It is comprised of a single job, `bump`, which checks out the PR, gets the version inside the `VERSION` file, and updates it depending on the command in the PR:

- `!bump major`: changes the version from `X.Y` ->`(X+1).0`. For example, `11.2` -> `12.0`.
- `!bump minor`: changes the version from `X.Y` -> `X.(Y+1)`. For example, `11.2` -> `11.3`.

This is then committed to the PR and the creator is notified that the version was successfully bumped. The PR is now mergable.

#### Preventing Half-formed PRs: `prevent-merge.yml`

This workflow creates an automatic failure condition in the case where reproducibility has failed and the `CHECKSUM` has been automatically updated in the PR, but the `VERSION` hasn't been bumped yet.

Once the appropriate `!bump` command has been issued, this check will pass, and the PR will be mergable.

#### The Last Step: `bump-tag.yml`

This workflow runs once the PR has been merged, taking the updated version in the `VERSION` file, and tagging the merge commit with this version.

### Triggered as a Scheduled Check

This pipeline uses the `schedule-1-ci.yml` and `schedule-2-start.yml` workflows.

The overall pipeline, which makes use of matrices, looks like this:

```txt
schedule-1-ci ---- schedule-2-start [release-1deg_jra55_iaf-1.1]
               |-- schedule-2-start [release-1deg_jra55_iaf-2.0]
                `- schedule-2-start [<other config tags>]
```

#### Matrix Creation: `schedule-1-ci.yml`

This workflow is responsible for getting all the config tags that require monthly checks (defined in `config/released-configs.json`) and spawning a matrix job for each of those.

As an aside, the reason that we call the reusable workflow `schedule-2-start.yml` with a matrix strategy is that matrix strategies only work at the `job` level. So, if you need a matrix to work across multiple jobs (for example, one job does a task with a particular matrix value, and one reports the result of that task), you need a job that calls a reusable workflow, which in turn contains multiple jobs.

#### Config Tag Specific Checks: `schedule-2-start.yml`

##### `repro-ci`

Exactly the same as the [`pr-1-ci.yml` counterpart](#repro-ci) - run the config associated with the given config tag and upload the checksum.

##### `check-repro`

Similar to the [`pr-1-ci.yml` counterpart](#check-repro), this job checks the recently generated checksum against the existing config tag - essentially a self-test.

##### `failed-repro`

If the reproduction check fails during a scheduled check, something is wrong. This job creates an issue in this repository, and tags the Release team for investigation.
